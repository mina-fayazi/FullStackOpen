# Part 6 - Full Stack Open

This directory contains the exercises for Part 6 of the FullStackOpen course.

## Exercises

### 6.1: Unicafe Revisited, step 1
- Implement the reducer for managing feedback counts using the `Redux` library for the unicafe project from part 1:
  - The state should contain counts for good, neutral (ok), and bad feedback.
  - Ensure the reducer returns the correct initial state when called with undefined state.
  - Ensure the reducer updates the correct feedback count based on the dispatched action.
- Implement tests for the reducer:
  - Use the `deep-freeze` library to ensure immutability.
  - Verify that the state is not mutated and a new state is returned correctly for each action type.

### 6.2: Unicafe Revisited, step 2
- Implement the user interface for giving feedback:
  - Add buttons for giving good, neutral, and bad feedback.
  - Add a button for resetting the feedback statistics to zero.
- The application should dynamically update statistics based on the feedback given.

### 6.3: Anecdotes, step 1
- Implement voting functionality using `Redux` for the anecdotes application from part 1:
  - Store the number of votes for each anecdote in the `Redux` store.
- When a user votes for an anecdote:
  - Dispatch an action that updates the vote count of the selected anecdote in the store.
  - Ensure the component updates to reflect the new number of votes.

### 6.4: Anecdotes, step 2
- Implement functionality for adding new anecdotes.
- The user should be able to submit a new anecdote using an uncontrolled form input.
- When a new anecdote is submitted:
  - Dispatch an action that adds the new anecdote to the `Redux` store.
  - Make sure the component updates to display the newly added anecdote.

### 6.5: Anecdotes, step 3
- Ensure anecdotes are ordered by the number of votes, highest first.
- Sort the anecdotes before rendering them:
  - Anecdotes with more votes should appear higher in the list.
  - After voting or adding a new anecdote, the order should automatically update.

### 6.6: Anecdotes, step 4
- Refactor the code by separating the creation of action objects into action creator functions.
- Move all action creators to the `src/reducers/anecdoteReducer.js` file.
- Update your components to use these action creators when dispatching actions, instead of directly creating action objects inside the component.

### 6.7: Anecdotes, step 5
- Create a new component called `AnecdoteForm` for adding a new anecdote:
  - The form and its submission handling should now be inside `AnecdoteForm`.
  - When the form is submitted, dispatch the action to add a new anecdote.
- Keep the `App` component cleaner by simply rendering the `AnecdoteForm` component.

### 6.8: Anecdotes, step 6
- Create a new component called `AnecdoteList` for rendering the anecdote list and voting for anecdotes:
  - Display the list of anecdotes inside `AnecdoteList`.
  - Handle the voting functionality (dispatching the vote action) inside this component.
- The `App` component should now only render the `AnecdoteForm` and `AnecdoteList` components, keeping it clean and modular.

### 6.9: Better Anecdotes, step 7
- Implement filtering functionality to control which anecdotes are displayed:
  - Add a new `Filter` component for rendering a text input that lets users filter anecdotes based on text content.
  - When the filter input changes, dispatch an action to update the filter value in the Redux store.
- Store the filter state in the Redux store:
  - Create a new reducer for managing the filter state.
  - Define appropriate action types and action creators for updating the filter.
  - Use `combineReducers` to combine the anecdote and filter reducers into a single root reducer.
- Update the `AnecdoteList` component:
  - Only display anecdotes that match the current filter text.
  - Ensure the filtering is case-insensitive and reflects live updates as the user types.

### 6.10: Better Anecdotes, step 8
- Set up `Redux Toolkit` to simplify Redux logic and improve development experience:
  - Move the store setup logic into a new file called `src/store.js`.
  - Use Redux Toolkit’s `configureStore` function to create the Redux store.
- Refactor the filter reducer in `src/reducers/filterReducer.js`:
  - Use Redux Toolkit’s `createSlice` to define the filter reducer and its associated action creators.
  - This change simplifies reducer logic and automatically generates action types and creators.
- Integrate `Redux DevTools` into the development workflow.

### 6.11: Better Anecdotes, step 9
- Refactor the anecdote reducer in `src/reducers/anecdoteReducer.js` to use Redux Toolkit:
  - Use the `createSlice` function to define the anecdote reducer and action creators.
  - Replace manually written action types and creators with the ones generated by the slice.
- Update the application to work seamlessly with the new reducer setup:
  - Ensure all imports of anecdote-related actions and reducers are updated to reflect the new slice structure.
- Important note on immutability:
  - The initial state returned by Redux Toolkit slices is immutable.
  - When sorting the list of anecdotes, always create a copy of the state array before sorting it to avoid runtime errors.

### 6.12: Better Anecdotes, step 10
- Implement a notification system using Redux Toolkit:
  - Create a new slice and reducer in a file named `notificationReducer.js`.
  - Define the initial notification message that should be displayed when the app loads.
  - Use `createSlice` to define the reducer and two action creators: one for setting a new notification and one for clearing it.
- Update the `Notification` component to display messages from the Redux store:
  - Connect the component to the Redux store using the `useSelector` hook.
  - Retrieve the current notification message from the store and render it inside a styled container.
- Integrate the notification reducer into the global Redux store:
  - Make sure to add the new reducer to the reducer configuration of the store defined in `src/store.js`.
- Display the notification component in the main app:
  - Ensure the `Notification` component is rendered at the top level of the application so it’s always visible.
  - At this stage, only the default notification message is displayed.

### 6.13: Better Anecdotes, step 11
- Extend the notification functionality so that a message is shown for five seconds when the user either:
  - Votes for an anecdote
  - Creates a new anecdote
- Update the notification logic by creating a custom action creator (`showNotification`) that:
  - Dispatches `setNotification(message)`
  - Waits for a fixed duration (e.g. 5 seconds)
  - Automatically dispatches `clearNotification()`
  - This pattern ensures:
    - Cleaner and more reusable code
    - Timeout logic is handled centrally in one place
- Update the relevant components:
  - In `AnecdoteList`, dispatch `showNotification("You voted: ...", 5)` after voting.
  - In `AnecdoteForm`, dispatch `showNotification("You created: ...", 5)` after a new anecdote is added.

### 6.14: Anecdotes and the Backend, step 1
- Connect the frontend application to the backend server using json-server:
  - Configure the backend to serve anecdote data from a JSON file.
  - When the application loads, fetch the list of anecdotes from the backend instead of using hardcoded data.

### 6.15: Anecdotes and the Backend, step 2
- Modify the logic for adding new anecdotes so they are stored on the backend:
  - Instead of adding anecdotes directly to the Redux state, send a POST request to the backend to create a new anecdote.
  - Once the backend confirms creation, update the Redux state using the response data.

### 6.16: Anecdotes and the Backend, step 3
- Refactor the Redux store initialization to use asynchronous action creators:
  - Utilize Redux Thunk to enable action creators to return functions instead of plain action objects.
  - Implement an asynchronous action creator (e.g. `initializeAnecdotes`) that:
    - Sends a request to the backend to fetch the list of anecdotes.
    - Dispatches an action to store the retrieved anecdotes in the Redux state.

### 6.17: Anecdotes and the Backend, step 4
- Refactor the process of creating new anecdotes to use asynchronous action creators:
  - Define an asynchronous action creator (e.g. `createAnecdote`) that:
    - Sends a POST request to the backend to add a new anecdote.
    - Dispatches an action to add the returned anecdote to the Redux store.

### 6.18: Anecdotes and the Backend, step 5
- Implement backend persistence for voting functionality:
  - Update the voting logic to send a PUT request to the backend with the modified anecdote (with an incremented vote count).
  - Create an asynchronous action creator (e.g. `voteAnecdoteAsync`) that:
    - Accepts an anecdote object as input.
    - Sends an update request to the backend.
    - Dispatches an action to update the anecdote in the Redux store using the returned updated data.
- This ensures that all vote changes are reflected in both the frontend and the backend, keeping data consistent.

### 6.19: Anecdotes and the Backend, step 6
- Simplify the notification creation process:
  - Create a utility action creator that accepts two parameters:
    - The notification message text.
    - The duration (in seconds) the message should be visible.
  - Internally handle setting the message and clearing it after the timeout using `setTimeout`.
- This abstraction avoids repetitive logic and improves code clarity when triggering notifications.
- This functionality was already implemented as part of exercise 6.13.

### 6.20: Anecdotes with React Query, step 1
- Replace Redux for fetching anecdotes with `React Query`:
  - Use the `useQuery` hook to fetch anecdote data from the backend.
  - Handle loading and error states appropriately.
  - If the server is unreachable or the request fails, display an error message:  
    `"anecdote service not available due to problems in server"`.
  - Customize the query's retry behavior if needed:
    - Disable retries with `retry: false`, or
    - Set limited retries with `retry: 1`.

### 6.21: Anecdotes with React Query, step 2
- Implement adding new anecdotes using React Query:
  - Use the `useMutation` hook to send new anecdote data to the backend.
  - Ensure that new anecdotes are automatically shown in the list upon successful creation.
  - The backend enforces a minimum content length of 5 characters for new anecdotes.
    - Do not worry about error handling for failed submissions at this point.

### 6.22: Anecdotes with React Query, step 3
- Implement voting functionality using React Query:
  - Use the `useMutation` hook to update the vote count of an anecdote on the backend.
  - Ensure the UI reflects the updated vote count immediately after a successful mutation.

### 6.23: Anecdotes with React Query, step 4
- Implement a notification system using `useReducer` and `React Context API`:
  - Create a `NotificationContext` that holds the notification message and a dispatch function.
  - Use the `useNotificationValue` and `useNotificationDispatch` hooks to access and update the notification state throughout the app.
- Update the application to display notifications for successful voting and successful creation of a new anecdote. 
- Notifications should disappear automatically after 5 seconds.

### 6.24: Anecdotes with React Query, step 5
- Handle errors when adding a new anecdote:
  - The backend enforces a minimum length of 5 characters for anecdote content.
  - If the user tries to add an anecdote with fewer than 5 characters, the backend responds with an error.
- Use the `onError` callback of the `useMutation` hook to catch this error:
  - Display the error message as a notification to the user:  
    `"too short anecdote, must have length 5 or more"`
  - The error notification should also disappear after 5 seconds.
